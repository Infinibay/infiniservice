//! Communication module for virtio-serial interface

use crate::collector::SystemInfo;
use anyhow::{Result, Context, anyhow};
use log::{info, error, debug, warn};
use serde::{Serialize, Deserialize};
use std::path::Path;
use std::fs::OpenOptions;
use std::io::{Write, BufRead, BufReader};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

#[derive(Serialize, Deserialize, Debug)]
pub struct PingMessage {
    #[serde(rename = "type")]
    pub message_type: String,
    pub timestamp: String,
    #[serde(rename = "vmId")]
    pub vm_id: String,
    #[serde(rename = "sequenceNumber")]
    pub sequence_number: Option<u64>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct PongMessage {
    #[serde(rename = "type")]
    pub message_type: String,
    pub timestamp: String,
    #[serde(rename = "vmId")]
    pub vm_id: String,
    #[serde(rename = "sequenceNumber")]
    pub sequence_number: Option<u64>,
}

pub struct VirtioSerial {
    device_path: std::path::PathBuf,
    vm_id: String,
    sequence_number: u64,
}

impl VirtioSerial {
    pub fn new<P: AsRef<Path>>(device_path: P) -> Self {
        Self {
            device_path: device_path.as_ref().to_path_buf(),
            vm_id: Self::generate_vm_id(),
            sequence_number: 0,
        }
    }

    pub fn with_vm_id<P: AsRef<Path>>(device_path: P, vm_id: String) -> Self {
        Self {
            device_path: device_path.as_ref().to_path_buf(),
            vm_id,
            sequence_number: 0,
        }
    }

    fn generate_vm_id() -> String {
        // Try to get VM ID from environment or generate one
        std::env::var("INFINIBAY_VM_ID")
            .unwrap_or_else(|_| Uuid::new_v4().to_string())
    }

    /// Detect virtio-serial device path based on platform
    pub fn detect_device_path(debug_mode: bool) -> Result<std::path::PathBuf> {
        #[cfg(target_os = "linux")]
        {
            Self::detect_linux_device(debug_mode)
        }

        #[cfg(target_os = "windows")]
        {
            Self::detect_windows_device(debug_mode)
        }

        #[cfg(not(any(target_os = "linux", target_os = "windows")))]
        {
            Err(anyhow!("Unsupported platform for virtio-serial detection"))
        }
    }

    #[cfg(target_os = "linux")]
    fn detect_linux_device(debug_mode: bool) -> Result<std::path::PathBuf> {
        if debug_mode {
            debug!("Starting Linux device detection...");
        }
        
        // Common virtio-serial device paths on Linux
        let possible_paths = [
            "/dev/virtio-ports/org.infinibay.ping",
            "/dev/virtio-ports/com.redhat.spice.0",
            "/dev/vport0p1",
            "/dev/vport1p1",
        ];

        if debug_mode {
            debug!("Checking common virtio-serial paths...");
        }
        
        for path in &possible_paths {
            if debug_mode {
                debug!("Checking: {}", path);
            }
            let device_path = std::path::Path::new(path);
            if device_path.exists() {
                info!("Found virtio-serial device at: {}", path);
                return Ok(device_path.to_path_buf());
            }
        }

        // Check for any virtio-ports device
        let virtio_dir = std::path::Path::new("/dev/virtio-ports");
        if debug_mode {
            debug!("Checking /dev/virtio-ports directory...");
        }
        if virtio_dir.exists() {
            if let Ok(entries) = std::fs::read_dir(virtio_dir) {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if debug_mode {
                        debug!("Found entry: {:?}", path);
                    }
                    // Check if it's a character device or regular file
                    if let Ok(metadata) = std::fs::metadata(&path) {
                        #[cfg(unix)]
                        {
                            use std::os::unix::fs::FileTypeExt;
                            if metadata.file_type().is_char_device() || metadata.file_type().is_file() {
                                info!("Found virtio-serial device at: {:?}", path);
                                return Ok(path);
                            }
                        }
                        #[cfg(not(unix))]
                        {
                            if metadata.is_file() {
                                info!("Found virtio-serial device at: {:?}", path);
                                return Ok(path);
                            }
                        }
                    }
                }
            }
        } else if debug_mode {
            debug!("/dev/virtio-ports directory does not exist");
        }

        Err(anyhow!("No virtio-serial device found on Linux"))
    }

    #[cfg(target_os = "windows")]
    fn detect_windows_device(debug_mode: bool) -> Result<std::path::PathBuf> {
        use crate::windows_com::{find_virtio_com_port, enumerate_com_ports, try_open_com_port, 
                                  find_virtio_system_devices, find_virtio_device_paths};
        use std::process::Command;
        use std::ffi::OsStr;
        use std::os::windows::ffi::OsStrExt;
        
        if debug_mode {
            debug!("Starting Windows device detection...");
        }
        
        // Helper function to create Windows device path
        fn create_device_path(device: &str) -> std::path::PathBuf {
            // For Windows, we need to ensure the path is properly formatted
            // Use OsString to avoid any escaping issues
            if device.starts_with("COM") {
                // COM port path
                std::path::PathBuf::from(format!("\\\\.\\{}", device))
            } else {
                // Already a full path
                std::path::PathBuf::from(device)
            }
        }
        
        // Method 1: First try VirtIO named pipes (most likely to work with proper VM config)
        if debug_mode {
            debug!("Method 1: Trying VirtIO named pipes and global objects...");
        }
        
        // IMPORTANTE: Solo intentar paths que realmente podrían existir
        // Intentar diferentes formatos de paths que VirtIO podría usar
        let virtio_paths: Vec<std::path::PathBuf> = vec![
            // Dispositivo VirtIO directo (sin namespace)
            std::path::PathBuf::from("\\\\.\\VirtioSerial"),
            std::path::PathBuf::from("\\\\.\\VirtioSerial0"),
            // Canales específicos como pipes
            std::path::PathBuf::from("\\\\.\\pipe\\org.infinibay.ping"),
            std::path::PathBuf::from("\\\\.\\pipe\\org.qemu.guest_agent.0"),
            // Global objects (aunque el error sugiere que no existen como archivos)
            std::path::PathBuf::from("\\\\.\\Global\\org.qemu.guest_agent.0"),
            std::path::PathBuf::from("\\\\.\\Global\\org.infinibay.ping"),
            std::path::PathBuf::from("\\\\.\\Global\\com.redhat.spice.0"),
        ];
        
        for path in &virtio_paths {
            if debug_mode {
                debug!("Trying VirtIO path: {}", path.display());
            }
            
            let path_str = path.to_string_lossy();
            
            // Los Global objects en Windows necesitan tratamiento especial
            // NO son archivos, son objetos del kernel
            if path_str.contains("Global") {
                // Para QEMU Guest Agent, intentar conectar via socket TCP local
                if path_str.contains("guest_agent") {
                    // QEMU GA normalmente escucha en un socket local
                    info!("Detectado QEMU Guest Agent - intentando conexión alternativa");
                    // Por ahora, marcamos como encontrado y manejamos diferente después
                    return Ok(path.clone());
                }
                
                // Para otros Global objects, intentar con CreateFile pero con flags diferentes
                use winapi::um::fileapi::{CreateFileW, OPEN_EXISTING};
                use winapi::um::winnt::{GENERIC_READ, GENERIC_WRITE};
                use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};
                use winapi::um::winbase::FILE_FLAG_OVERLAPPED;
                use std::os::windows::ffi::OsStrExt;
                use std::ffi::OsStr;
                
                let wide_path: Vec<u16> = OsStr::new(&*path_str)
                    .encode_wide()
                    .chain(std::iter::once(0))
                    .collect();
                
                unsafe {
                    // Intentar abrir con diferentes combinaciones de flags
                    let handle = CreateFileW(
                        wide_path.as_ptr(),
                        GENERIC_READ | GENERIC_WRITE,
                        0, // Sin compartir
                        std::ptr::null_mut(),
                        OPEN_EXISTING,
                        FILE_FLAG_OVERLAPPED, // Agregar flag de overlapped
                        std::ptr::null_mut(),
                    );
                    
                    if handle != INVALID_HANDLE_VALUE {
                        CloseHandle(handle);
                        info!("✅ Found working VirtIO Global device at: {}", path.display());
                        return Ok(path.clone());
                    } else if debug_mode {
                        use winapi::um::errhandlingapi::GetLastError;
                        let error = GetLastError();
                        debug!("Cannot open Global object {}: Win32 error {}", path.display(), error);
                        
                        // Error 2 = File not found - el path no existe
                        // Error 5 = Access denied - existe pero no tenemos permisos
                        if error == 2 {
                            debug!("  -> El path no existe en el sistema");
                        } else if error == 5 {
                            debug!("  -> Acceso denegado (puede necesitar permisos de administrador)");
                        }
                    }
                }
            } else {
                // For pipes and regular paths, use standard file operations
                use std::fs::OpenOptions;
                match OpenOptions::new()
                    .read(true)
                    .write(true)
                    .open(path)
                {
                    Ok(_) => {
                        info!("✅ Found working VirtIO device at: {}", path.display());
                        return Ok(path.clone());
                    }
                    Err(e) => {
                        if debug_mode {
                            debug!("Cannot open {}: {}", path.display(), e);
                        }
                    }
                }
            }
        }
        
        // Method 2: Check for VirtIO system devices (like in Device Manager)
        if debug_mode {
            debug!("Method 2: Searching for VirtIO devices in system devices...");
        }
        match find_virtio_system_devices() {
            Ok(devices) => {
                if !devices.is_empty() {
                    info!("Found {} VirtIO system device(s):", devices.len());
                    for device in &devices {
                        info!("  - {} (Hardware ID: {})", 
                              device.friendly_name, device.hardware_id);
                        
                        // Check if it's the specific device from the screenshot
                        if device.hardware_id.contains("DEV_1043") {
                            info!("Found VirtIO Serial Device (DEV_1043) as seen in Device Manager");
                            warn!("Note: This device may not be accessible as a COM port.");
                            warn!("The VirtIO serial driver may need additional configuration.");
                        }
                    }
                }
            }
            Err(e) => {
                if debug_mode {
                    debug!("Failed to enumerate system devices: {}", e);
                }
            }
        }
        
        // Method 3: Try alternative VirtIO device paths
        if debug_mode {
            debug!("Method 2: Trying alternative VirtIO device paths...");
        }
        let virtio_paths = find_virtio_device_paths();
        if !virtio_paths.is_empty() {
            info!("Found {} alternative VirtIO device path(s)", virtio_paths.len());
            for path in virtio_paths {
                info!("Using VirtIO device path: {}", path.display());
                return Ok(path);
            }
        }
        
        // Method 4: Try to find a virtio COM port by hardware ID
        if debug_mode {
            debug!("Method 3: Searching for VirtIO COM port by hardware ID...");
        }
        match find_virtio_com_port() {
            Ok(port_info) => {
                info!("Found VirtIO COM port: {} ({})", port_info.port_name, port_info.friendly_name);
                info!("Hardware ID: {}", port_info.hardware_id);
                
                // Try to open it to verify it's accessible
                if let Err(e) = try_open_com_port(&port_info.port_name) {
                    warn!("Found VirtIO port {} but cannot open it: {}", port_info.port_name, e);
                } else {
                    info!("Successfully verified access to {}", port_info.port_name);
                }
                
                return Ok(port_info.device_path);
            }
            Err(e) => {
                if debug_mode {
                    debug!("Method 3 failed: {}", e);
                }
                warn!("Could not find VirtIO COM port automatically: {}", e);
            }
        }
        
        // Method 5: Use wmic to find VirtIO ports
        if debug_mode {
            debug!("Method 4: Using wmic to search for VirtIO ports...");
        }
        let wmic_output = Command::new("wmic")
            .args(&["path", "Win32_SerialPort", "where", "PNPDeviceID like '%VEN_1AF4%'", "get", "DeviceID", "/format:csv"])
            .output();
        
        if let Ok(output) = wmic_output {
            let output_str = String::from_utf8_lossy(&output.stdout);
            if debug_mode {
                debug!("WMIC output: {}", output_str);
            }
            for line in output_str.lines() {
                if line.contains("COM") {
                    let parts: Vec<&str> = line.split(',').collect();
                    if let Some(com_port) = parts.iter().find(|p| p.starts_with("COM")) {
                        let com_port = com_port.trim();
                        let device_path = create_device_path(com_port);
                        info!("Found VirtIO COM port via WMIC: {}", device_path.display());
                        
                        // Verify we can open it
                        if let Err(e) = try_open_com_port(com_port) {
                            warn!("WMIC found {} but cannot open it: {}", com_port, e);
                        } else {
                            return Ok(device_path);
                        }
                    }
                }
            }
        } else if debug_mode {
            debug!("WMIC command failed or not available");
        }
        
        // Method 6: Use PowerShell to find VirtIO ports
        if debug_mode {
            debug!("Method 5: Using PowerShell to search for VirtIO ports...");
        }
        let ps_output = Command::new("powershell")
            .args(&[
                "-Command", 
                "Get-WmiObject -Class Win32_SerialPort | Where-Object {$_.PNPDeviceID -like '*VEN_1AF4*' -or $_.Name -like '*VirtIO*'} | Select-Object -ExpandProperty DeviceID"
            ])
            .output();
        
        if let Ok(output) = ps_output {
            let output_str = String::from_utf8_lossy(&output.stdout);
            if debug_mode {
                debug!("PowerShell output: {}", output_str);
            }
            for line in output_str.lines() {
                let line = line.trim();
                if line.starts_with("COM") {
                    let device_path = create_device_path(line);
                    info!("Found VirtIO COM port via PowerShell: {}", device_path.display());
                    
                    // Verify we can open it
                    if let Err(e) = try_open_com_port(line) {
                        warn!("PowerShell found {} but cannot open it: {}", line, e);
                    } else {
                        return Ok(device_path);
                    }
                }
            }
        } else if debug_mode {
            debug!("PowerShell command failed or not available");
        }
        
        // Method 7: Try common COM ports
        if debug_mode {
            debug!("Method 6: Trying common COM ports (COM1-COM10)...");
        }
        for i in 1..=10 {
            let com_port = format!("COM{}", i);
            let device_path = create_device_path(&com_port);
            
            if debug_mode {
                debug!("Trying {}", device_path.display());
            }
            
            // Try to open the port to verify it exists
            match try_open_com_port(&com_port) {
                Ok(_) => {
                    info!("Found available COM port: {}", device_path.display());
                    // For the first 4 COM ports, assume they might be virtio
                    if i <= 4 {
                        warn!("Using {} as potential virtio-serial port", com_port);
                        return Ok(device_path);
                    }
                }
                Err(e) => {
                    if debug_mode {
                        debug!("{} not available: {}", com_port, e);
                    }
                }
            }
        }
        
        // Method 8: Try additional named pipes (fallback)
        if debug_mode {
            debug!("Method 7: Trying named pipes...");
        }
        // Use OS-specific string handling for named pipes
        let named_pipes: Vec<std::path::PathBuf> = vec![
            std::path::PathBuf::from("\\\\.\\Global\\org.infinibay.ping"),
            std::path::PathBuf::from("\\\\.\\Global\\com.redhat.spice.0"),
            std::path::PathBuf::from("\\\\.\\pipe\\org.infinibay.ping"),
            std::path::PathBuf::from("\\\\.\\pipe\\virtio-serial"),
        ];
        
        for path in &named_pipes {
            if debug_mode {
                debug!("Trying named pipe: {}", path.display());
            }
            // Try to open the named pipe
            use std::fs::OpenOptions;
            if let Ok(_) = OpenOptions::new()
                .read(true)
                .write(true)
                .open(&path)
            {
                info!("Found working virtio-serial named pipe: {}", path.display());
                return Ok(path.clone());
            }
        }
        
        // Last resort: List all available COM ports for debugging
        warn!("No virtio-serial device found. Available COM ports:");
        if let Ok(ports) = enumerate_com_ports() {
            for port in ports {
                warn!("  - {} ({}): {}", port.port_name, port.friendly_name, port.hardware_id);
                if debug_mode {
                    debug!("    Full hardware ID: {}", port.hardware_id);
                    debug!("    Can open: {:?}", try_open_com_port(&port.port_name).is_ok());
                }
            }
        }
        
        // Additional diagnostic information
        warn!("=== VirtIO Device Detection Summary ===");
        warn!("No accessible VirtIO serial device found.");
        warn!("");
        warn!("Based on your Device Manager screenshot, the VirtIO Serial Driver IS installed");
        warn!("(Device: PCI\\VEN_1AF4&DEV_1043&SUBSYS_11001AF4&REV_01)");
        warn!("");
        warn!("However, this device is not appearing as a COM port.");
        warn!("This can happen when:");
        warn!("1. The VirtIO serial device is configured but not exposed as a COM port");
        warn!("2. The device needs a specific channel name configured in the VM XML");
        warn!("3. Windows needs additional configuration to expose the device");
        warn!("");
        warn!("To fix this issue:");
        warn!("1. Check the VM configuration for the virtio-serial channel name");
        warn!("2. Ensure the channel has target type='virtio' and name='org.infinibay.ping'");
        warn!("3. Try reinstalling the VirtIO serial driver with the latest version");
        warn!("4. Check if the device appears under Ports (COM & LPT) after driver reinstall");
        warn!("");
        warn!("You can also try manually specifying the device path with --device flag");
        warn!("========================================");
        
        Err(anyhow!("No accessible virtio-serial device found. See log output above for diagnostic information."))
    }
    
    /// Initialize connection to virtio-serial device
    pub async fn connect(&self) -> Result<()> {
        info!("Connecting to virtio-serial device: {}", self.device_path.display());

        // Test if we can open the device for writing
        #[cfg(target_os = "windows")]
        {
            let path_str = self.device_path.to_string_lossy();
            
            // Check device type and handle accordingly
            if path_str.contains("Global") {
                // Test if we can actually open the Global object
                use winapi::um::fileapi::{CreateFileW, OPEN_EXISTING};
                use winapi::um::winnt::{GENERIC_READ, GENERIC_WRITE, FILE_SHARE_READ, FILE_SHARE_WRITE};
                use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};
                use std::os::windows::ffi::OsStrExt;
                use std::ffi::OsStr;
                
                let wide_path: Vec<u16> = OsStr::new(&*path_str)
                    .encode_wide()
                    .chain(std::iter::once(0))
                    .collect();
                
                unsafe {
                    let handle = CreateFileW(
                        wide_path.as_ptr(),
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        std::ptr::null_mut(),
                        OPEN_EXISTING,
                        0,
                        std::ptr::null_mut(),
                    );
                    
                    if handle == INVALID_HANDLE_VALUE {
                        use winapi::um::errhandlingapi::GetLastError;
                        let error = GetLastError();
                        return Err(anyhow!("Failed to open Global object {}: Win32 error {}", path_str, error));
                    }
                    
                    // Close the test handle
                    CloseHandle(handle);
                }
                
                debug!("Global VirtIO device verified: {}", path_str);
                info!("VirtIO Global object ready - will use Windows API for communication");
                return Ok(());
            } else if path_str.contains("COM") && !path_str.contains("pipe") {
                // It's a COM port, open with appropriate flags
                use std::os::windows::fs::OpenOptionsExt;
                use winapi::um::winbase::FILE_FLAG_OVERLAPPED;
                
                let _file = OpenOptions::new()
                    .write(true)
                    .read(true)
                    .custom_flags(FILE_FLAG_OVERLAPPED)
                    .open(&self.device_path)
                    .with_context(|| format!("Failed to open COM port: {}", self.device_path.display()))?;
                
                info!("COM port connection established successfully");
            } else {
                // It's a named pipe or other device
                let _file = OpenOptions::new()
                    .write(true)
                    .read(true)
                    .open(&self.device_path)
                    .with_context(|| format!("Failed to open device: {}", self.device_path.display()))?;
                
                info!("Device connection established successfully");
            }
        }
        
        #[cfg(not(target_os = "windows"))]
        {
            let _file = OpenOptions::new()
                .write(true)
                .read(true)
                .open(&self.device_path)
                .with_context(|| format!("Failed to open virtio-serial device: {}", self.device_path.display()))?;

            info!("Virtio-serial connection established successfully");
        }
        
        Ok(())
    }

    /// Send a ping message to the host
    pub async fn send_ping(&mut self) -> Result<()> {
        #[cfg(target_os = "windows")]
        {
            // Check device type and use appropriate method
            let path_str = self.device_path.to_string_lossy();
            if path_str.contains("Global") {
                // For Global objects, use Windows API directly
                return self.send_ping_windows_global().await;
            } else if path_str.contains("COM") && !path_str.contains("pipe") {
                // For COM ports, use serialport crate
                return self.send_ping_windows_serialport().await;
            }
        }
        self.sequence_number += 1;

        let ping_message = PingMessage {
            message_type: "ping".to_string(),
            timestamp: Self::current_timestamp(),
            vm_id: self.vm_id.clone(),
            sequence_number: Some(self.sequence_number),
        };

        let message_json = serde_json::to_string(&ping_message)?;
        debug!("🏓 Sending PING: {}", message_json);

        // Open device and send message
        #[cfg(target_os = "windows")]
        let mut file = {
            use std::os::windows::fs::OpenOptionsExt;
            let path_str = self.device_path.to_string_lossy();
            if path_str.contains("COM") && !path_str.contains("pipe") {
                // COM port - no special flags needed for synchronous write
                OpenOptions::new()
                    .write(true)
                    .open(&self.device_path)
                    .with_context(|| format!("Failed to open COM port for writing: {}", self.device_path.display()))?
            } else {
                OpenOptions::new()
                    .write(true)
                    .open(&self.device_path)
                    .with_context(|| format!("Failed to open device for writing: {}", self.device_path.display()))?
            }
        };
        
        #[cfg(not(target_os = "windows"))]
        let mut file = OpenOptions::new()
            .write(true)
            .open(&self.device_path)
            .with_context(|| format!("Failed to open device for writing: {}", self.device_path.display()))?;

        writeln!(file, "{}", message_json)
            .with_context(|| "Failed to write ping message to device")?;

        file.flush()
            .with_context(|| "Failed to flush data to device")?;

        info!("🏓 PING sent to host (sequence: {})", self.sequence_number);
        Ok(())
    }

    /// Listen for pong messages from the host
    pub async fn listen_for_pong(&self, timeout_secs: u64) -> Result<Option<PongMessage>> {
        #[cfg(target_os = "windows")]
        {
            // Check if it's a COM port and use serialport if available  
            let path_str = self.device_path.to_string_lossy();
            if path_str.contains("COM") && !path_str.contains("pipe") {
                return self.listen_for_pong_windows_serialport(timeout_secs).await;
            }
        }
        debug!("Listening for PONG message...");

        // Open device for reading
        let file = OpenOptions::new()
            .read(true)
            .open(&self.device_path)
            .with_context(|| format!("Failed to open device for reading: {}", self.device_path.display()))?;

        let mut reader = BufReader::new(file);
        let mut line = String::new();

        // Simple timeout implementation (in a real implementation, you'd use async timeout)
        let start_time = std::time::Instant::now();

        loop {
            if start_time.elapsed().as_secs() > timeout_secs {
                debug!("Timeout waiting for PONG message");
                return Ok(None);
            }

            // Try to read a line (non-blocking would be better)
            match reader.read_line(&mut line) {
                Ok(0) => {
                    // EOF reached, wait a bit and try again
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                    continue;
                }
                Ok(_) => {
                    let trimmed = line.trim();
                    if !trimmed.is_empty() {
                        debug!("Received message: {}", trimmed);

                        // Try to parse as JSON
                        match serde_json::from_str::<PongMessage>(trimmed) {
                            Ok(pong) => {
                                if pong.message_type == "pong" {
                                    info!("🏓 PONG received from host (sequence: {:?})", pong.sequence_number);
                                    return Ok(Some(pong));
                                }
                            }
                            Err(e) => {
                                debug!("Failed to parse message as PONG: {}", e);
                            }
                        }
                    }
                    line.clear();
                }
                Err(e) => {
                    warn!("Error reading from device: {}", e);
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                }
            }
        }
    }

    fn current_timestamp() -> String {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs()
            .to_string()
    }
    
    /// Send system information to host via virtio-serial
    pub async fn send_data(&self, data: &SystemInfo) -> Result<()> {
        debug!("Sending system data via virtio-serial");

        let serialized = serde_json::to_string(data)
            .with_context(|| "Failed to serialize system data")?;

        // Open device and send data
        #[cfg(target_os = "windows")]
        let mut file = {
            use std::os::windows::fs::OpenOptionsExt;
            let path_str = self.device_path.to_string_lossy();
            if path_str.contains("COM") && !path_str.contains("pipe") {
                // COM port - no special flags needed for synchronous write
                OpenOptions::new()
                    .write(true)
                    .open(&self.device_path)
                    .with_context(|| format!("Failed to open COM port for data transmission: {}", self.device_path.display()))?
            } else {
                OpenOptions::new()
                    .write(true)
                    .open(&self.device_path)
                    .with_context(|| format!("Failed to open device for data transmission: {}", self.device_path.display()))?
            }
        };
        
        #[cfg(not(target_os = "windows"))]
        let mut file = OpenOptions::new()
            .write(true)
            .open(&self.device_path)
            .with_context(|| format!("Failed to open device for data transmission: {}", self.device_path.display()))?;

        writeln!(file, "{}", serialized)
            .with_context(|| "Failed to write system data to device")?;

        file.flush()
            .with_context(|| "Failed to flush system data to device")?;

        info!("System data sent successfully");
        Ok(())
    }

    /// Check if virtio-serial device is available
    pub fn is_available(&self) -> bool {
        self.device_path.exists()
    }

    /// Run ping-pong test loop
    pub async fn run_ping_pong_test(&mut self, interval_secs: u64) -> Result<()> {
        info!("Starting ping-pong test with {}s interval", interval_secs);

        loop {
            // Send ping
            if let Err(e) = self.send_ping().await {
                error!("Failed to send ping: {}", e);
                tokio::time::sleep(tokio::time::Duration::from_secs(interval_secs)).await;
                continue;
            }

            // Wait for pong
            match self.listen_for_pong(5).await {
                Ok(Some(pong)) => {
                    info!("✅ Ping-pong successful! Received: {:?}", pong);
                }
                Ok(None) => {
                    warn!("⏰ Timeout waiting for pong response");
                }
                Err(e) => {
                    error!("❌ Error listening for pong: {}", e);
                }
            }

            // Wait before next ping
            tokio::time::sleep(tokio::time::Duration::from_secs(interval_secs)).await;
        }
    }
    
    #[cfg(target_os = "windows")]
    /// Send a ping message to Windows Global object (VirtIO device)
    async fn send_ping_windows_global(&mut self) -> Result<()> {
        use winapi::um::fileapi::{CreateFileW, OPEN_EXISTING};
        use winapi::um::winnt::{GENERIC_READ, GENERIC_WRITE};
        use winapi::um::handleapi::{CloseHandle, INVALID_HANDLE_VALUE};
        use std::os::windows::ffi::OsStrExt;
        use std::ffi::OsStr;
        use std::ptr;
        
        self.sequence_number += 1;

        let ping_message = PingMessage {
            message_type: "ping".to_string(),
            timestamp: Self::current_timestamp(),
            vm_id: self.vm_id.clone(),
            sequence_number: Some(self.sequence_number),
        };

        let message_json = serde_json::to_string(&ping_message)?;
        debug!("🏓 Sending PING to Global object: {}", message_json);

        // Convert path to wide string for Windows API
        let path_str = self.device_path.to_string_lossy();
        let wide_path: Vec<u16> = OsStr::new(&*path_str)
            .encode_wide()
            .chain(std::iter::once(0))
            .collect();

        unsafe {
            // Open the Global object with CreateFileW
            let handle = CreateFileW(
                wide_path.as_ptr(),
                GENERIC_WRITE | GENERIC_READ,
                0,
                ptr::null_mut(),
                OPEN_EXISTING,
                0,
                ptr::null_mut(),
            );

            if handle == INVALID_HANDLE_VALUE {
                use winapi::um::errhandlingapi::GetLastError;
                let error = GetLastError();
                return Err(anyhow!("Failed to open Global object {}: Win32 error {}", path_str, error));
            }

            // Write the message
            use winapi::um::fileapi::WriteFile;
            let data = format!("{}\r\n", message_json);
            let bytes = data.as_bytes();
            let mut bytes_written = 0;

            let success = WriteFile(
                handle,
                bytes.as_ptr() as *const _,
                bytes.len() as u32,
                &mut bytes_written,
                ptr::null_mut(),
            );

            // Close handle
            CloseHandle(handle);

            if success == 0 {
                use winapi::um::errhandlingapi::GetLastError;
                let error = GetLastError();
                return Err(anyhow!("Failed to write to Global object: Win32 error {}", error));
            }

            info!("🏓 PING sent to host via Global object (sequence: {})", self.sequence_number);
            Ok(())
        }
    }
    
    #[cfg(target_os = "windows")]
    /// Send a ping message using serialport crate (Windows-specific)
    async fn send_ping_windows_serialport(&mut self) -> Result<()> {
        use serialport::SerialPort;
        
        self.sequence_number += 1;

        let ping_message = PingMessage {
            message_type: "ping".to_string(),
            timestamp: Self::current_timestamp(),
            vm_id: self.vm_id.clone(),
            sequence_number: Some(self.sequence_number),
        };

        let message_json = serde_json::to_string(&ping_message)?;
        debug!("🏓 Sending PING via serialport: {}", message_json);

        // Extract COM port name from path like \\.\COM3
        let path_str = self.device_path.to_string_lossy();
        let port_name = if path_str.starts_with("\\\\.\\")
            { &path_str[4..] } else { &path_str };
        
        // Open serial port with appropriate settings
        let mut port = serialport::new(port_name, 9600)
            .timeout(std::time::Duration::from_millis(1000))
            .data_bits(serialport::DataBits::Eight)
            .parity(serialport::Parity::None)
            .stop_bits(serialport::StopBits::One)
            .flow_control(serialport::FlowControl::None)
            .open()
            .with_context(|| format!("Failed to open COM port: {}", port_name))?;

        // Write message with CRLF line ending
        let data = format!("{}\r\n", message_json);
        port.write_all(data.as_bytes())
            .with_context(|| "Failed to write ping message to COM port")?;
        
        port.flush()
            .with_context(|| "Failed to flush COM port")?;

        info!("🏓 PING sent to host via {} (sequence: {})", port_name, self.sequence_number);
        Ok(())
    }
    
    #[cfg(target_os = "windows")]
    /// Listen for pong messages using serialport crate (Windows-specific)
    async fn listen_for_pong_windows_serialport(&self, timeout_secs: u64) -> Result<Option<PongMessage>> {
        use serialport::SerialPort;
        use std::io::Read;
        
        debug!("Listening for PONG message via serialport...");

        // Extract COM port name from path
        let path_str = self.device_path.to_string_lossy();
        let port_name = if path_str.starts_with("\\\\.\\")
            { &path_str[4..] } else { &path_str };
        
        // Open serial port for reading
        let mut port = serialport::new(port_name, 9600)
            .timeout(std::time::Duration::from_millis(100)) // Short timeout for non-blocking reads
            .data_bits(serialport::DataBits::Eight)
            .parity(serialport::Parity::None)
            .stop_bits(serialport::StopBits::One)
            .flow_control(serialport::FlowControl::None)
            .open()
            .with_context(|| format!("Failed to open COM port for reading: {}", port_name))?;

        let mut buffer = [0u8; 1024];
        let mut message_buffer = String::new();
        let start_time = std::time::Instant::now();

        loop {
            if start_time.elapsed().as_secs() > timeout_secs {
                debug!("Timeout waiting for PONG message");
                return Ok(None);
            }

            match port.read(&mut buffer) {
                Ok(0) => {
                    // No data available, wait a bit
                    tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
                    continue;
                }
                Ok(n) => {
                    let chunk = String::from_utf8_lossy(&buffer[..n]);
                    message_buffer.push_str(&chunk);
                    
                    // Check if we have complete lines
                    while let Some(newline_pos) = message_buffer.find('\n') {
                        let line = message_buffer[..newline_pos].trim().to_string();
                        message_buffer = message_buffer[newline_pos + 1..].to_string();
                        
                        if !line.is_empty() {
                            debug!("Received message via serialport: {}", line);
                            
                            match serde_json::from_str::<PongMessage>(&line) {
                                Ok(pong) => {
                                    if pong.message_type == "pong" {
                                        info!("🏓 PONG received from host via {} (sequence: {:?})", 
                                              port_name, pong.sequence_number);
                                        return Ok(Some(pong));
                                    }
                                }
                                Err(e) => {
                                    debug!("Failed to parse message as PONG: {}", e);
                                }
                            }
                        }
                    }
                }
                Err(ref e) if e.kind() == std::io::ErrorKind::TimedOut => {
                    // Timeout is expected with short timeout setting
                    tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
                    continue;
                }
                Err(e) => {
                    debug!("Error reading from COM port: {}", e);
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_ping_message_serialization() {
        let ping = PingMessage {
            message_type: "ping".to_string(),
            timestamp: "1234567890".to_string(),
            vm_id: "test-vm-123".to_string(),
            sequence_number: Some(5),
        };

        let json = serde_json::to_string(&ping).expect("Should serialize ping message");
        assert!(json.contains("\"type\":\"ping\""));
        assert!(json.contains("\"vmId\":\"test-vm-123\""));
        assert!(json.contains("\"sequenceNumber\":5"));

        let deserialized: PingMessage = serde_json::from_str(&json).expect("Should deserialize ping message");
        assert_eq!(ping.message_type, deserialized.message_type);
        assert_eq!(ping.vm_id, deserialized.vm_id);
        assert_eq!(ping.sequence_number, deserialized.sequence_number);
    }

    #[test]
    fn test_pong_message_serialization() {
        let pong = PongMessage {
            message_type: "pong".to_string(),
            timestamp: "1234567890".to_string(),
            vm_id: "test-vm-456".to_string(),
            sequence_number: Some(10),
        };

        let json = serde_json::to_string(&pong).expect("Should serialize pong message");
        assert!(json.contains("\"type\":\"pong\""));
        assert!(json.contains("\"vmId\":\"test-vm-456\""));
        assert!(json.contains("\"sequenceNumber\":10"));

        let deserialized: PongMessage = serde_json::from_str(&json).expect("Should deserialize pong message");
        assert_eq!(pong.message_type, deserialized.message_type);
        assert_eq!(pong.vm_id, deserialized.vm_id);
        assert_eq!(pong.sequence_number, deserialized.sequence_number);
    }

    #[test]
    fn test_virtio_serial_initialization() {
        let device_path = PathBuf::from("/dev/virtio-ports/test");
        let virtio = VirtioSerial::new(&device_path);
        
        assert_eq!(virtio.device_path, device_path);
        assert!(!virtio.vm_id.is_empty());
        assert_eq!(virtio.sequence_number, 0);
    }

    #[test]
    fn test_virtio_serial_with_vm_id() {
        let device_path = PathBuf::from("/dev/virtio-ports/test");
        let vm_id = "custom-vm-id";
        let virtio = VirtioSerial::with_vm_id(&device_path, vm_id.to_string());
        
        assert_eq!(virtio.device_path, device_path);
        assert_eq!(virtio.vm_id, vm_id);
        assert_eq!(virtio.sequence_number, 0);
    }

    #[test]
    fn test_vm_id_generation() {
        let vm_id1 = VirtioSerial::generate_vm_id();
        let vm_id2 = VirtioSerial::generate_vm_id();
        
        assert!(!vm_id1.is_empty());
        assert!(!vm_id2.is_empty());
        // IDs should be different unless environment variable is set
        if std::env::var("INFINIBAY_VM_ID").is_err() {
            assert_ne!(vm_id1, vm_id2);
        }
    }

    #[test]
    fn test_vm_id_from_environment() {
        let test_vm_id = "test-env-vm-id";
        std::env::set_var("INFINIBAY_VM_ID", test_vm_id);
        
        let generated_id = VirtioSerial::generate_vm_id();
        assert_eq!(generated_id, test_vm_id);
        
        // Clean up
        std::env::remove_var("INFINIBAY_VM_ID");
    }

    #[cfg(target_os = "linux")]
    #[test]
    fn test_linux_device_detection_paths() {
        // Test that detection tries expected Linux paths
        let result = VirtioSerial::detect_device_path(false);
        // This will likely fail in test environment, but shouldn't panic
        assert!(result.is_ok() || result.is_err());
    }

    #[cfg(target_os = "windows")]
    #[test]
    fn test_windows_device_detection_paths() {
        // Test that detection returns expected Windows paths
        let result = VirtioSerial::detect_device_path(false);
        if let Ok(path) = result {
            let path_str = path.to_string_lossy();
            assert!(path_str.contains(r"\\.\") || path_str.contains("Global"));
        }
    }

    #[test]
    fn test_current_timestamp() {
        let timestamp1 = VirtioSerial::current_timestamp();
        std::thread::sleep(std::time::Duration::from_millis(1));
        let timestamp2 = VirtioSerial::current_timestamp();
        
        assert!(!timestamp1.is_empty());
        assert!(!timestamp2.is_empty());
        
        let t1: u64 = timestamp1.parse().expect("Should be valid timestamp");
        let t2: u64 = timestamp2.parse().expect("Should be valid timestamp");
        assert!(t2 >= t1, "Second timestamp should be >= first");
    }

    #[test]
    fn test_is_available_with_nonexistent_path() {
        let nonexistent_path = PathBuf::from("/nonexistent/path/test.socket");
        let virtio = VirtioSerial::new(&nonexistent_path);
        
        assert!(!virtio.is_available());
    }

    #[tokio::test]
    async fn test_send_data_with_sample_system_info() {
        use crate::collector::*;
        
        // Create sample system info
        let system_info = SystemInfo {
            timestamp: 1234567890,
            metrics: SystemMetrics {
                cpu: CpuMetrics {
                    usage_percent: 50.0,
                    cores_usage: vec![45.0, 55.0],
                    temperature: Some(65.0),
                },
                memory: MemoryMetrics {
                    total_kb: 8388608,
                    used_kb: 4194304,
                    available_kb: 4194304,
                    swap_total_kb: None,
                    swap_used_kb: None,
                },
                disk: DiskMetrics {
                    usage_stats: vec![],
                    io_stats: DiskIOStats {
                        read_bytes_per_sec: 0,
                        write_bytes_per_sec: 0,
                        read_ops_per_sec: 0,
                        write_ops_per_sec: 0,
                    },
                },
                network: NetworkMetrics { interfaces: vec![] },
                system: SystemInfoMetrics {
                    uptime_seconds: 3600,
                    name: "Test".to_string(),
                    os_version: "1.0".to_string(),
                    kernel_version: "5.0".to_string(),
                    hostname: "test-host".to_string(),
                    load_average: None,
                },
                processes: vec![],
                ports: vec![],
                windows_services: vec![],
            },
        };

        // Test serialization (actual sending will fail in test environment)
        let serialized = serde_json::to_string(&system_info).expect("Should serialize");
        assert!(serialized.contains("\"timestamp\":1234567890"));
        assert!(serialized.contains("\"usage_percent\":50.0"));
    }

    #[test]
    fn test_message_structure_compatibility() {
        // Test that our message structures are compatible with the expected format
        
        // Test ping message JSON structure
        let ping = PingMessage {
            message_type: "ping".to_string(),
            timestamp: "1234567890".to_string(),
            vm_id: "vm-123".to_string(),
            sequence_number: Some(1),
        };
        
        let json = serde_json::to_string(&ping).unwrap();
        let value: serde_json::Value = serde_json::from_str(&json).unwrap();
        
        // Check JSON field names match expected API
        assert_eq!(value["type"], "ping");
        assert_eq!(value["vmId"], "vm-123");
        assert_eq!(value["sequenceNumber"], 1);
        assert_eq!(value["timestamp"], "1234567890");
    }
}
